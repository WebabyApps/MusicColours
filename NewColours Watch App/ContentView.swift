//  
//  ContentView.swift
//  NewColours Watch App
//
//  Created by Tomasz Szornel on 1/14/26.
//

import SwiftUI
import AVFoundation
import Combine
import WatchKit
import Accelerate
import StoreKit

private enum AppLanguage: String, CaseIterable, Identifiable { case pl, en; var id: String { rawValue } }

// MARK: - Floating Notes Layer (extracted from AnimatedDepthBackground)
private struct FloatingNotesLayer: View {
    let t: Double
    let bgSpeed: Double
    let colors: [Color]
    var body: some View {
        let noteCount = Int(4 + (sin(t / max(4.0, bgSpeed)) + 1) * 2)
        return ZStack {
            ForEach(0..<noteCount, id: \.self) { i in
                let nt = t / max(5.0, bgSpeed * 0.9) + Double(i) * 0.7
                let size = CGFloat(20 + (i % 5) * 4)
                let baseOpacity = 0.08 + Double((i % 4)) * 0.03
                let ampXBase = 40 + (i % 3) * 15
                let ampYBase = 30 + (i % 4) * 12
                let speedScale = CGFloat(12.0 / max(6.0, bgSpeed))
                let ampX = CGFloat(ampXBase) * speedScale
                let ampY = CGFloat(ampYBase) * speedScale
                let traj = i % 3
                let sx = sin(nt)
                let cx = cos(nt)
                let s07 = sin(nt * 0.7 + 0.8)
                let s05 = sin(nt * 0.5)
                let c06 = cos(nt * 0.6)
                let c08 = cos(nt * 0.8 + 0.5)
                let x: CGFloat = {
                    switch traj {
                    case 0: return sx * ampX
                    case 1: return s07 * ampX * 0.8
                    default: return c06 * ampX * 0.9
                    }
                }()
                let y: CGFloat = {
                    switch traj {
                    case 0: return cos(nt * 0.9) * ampY
                    case 1: return s05 * ampY
                    default: return c08 * ampY
                    }
                }()
                Image(systemName: i % 2 == 0 ? "music.note" : "music.quarternote.3")
                    .font(.system(size: size, weight: .regular))
                    .foregroundStyle(.white.opacity(baseOpacity))
                    .rotationEffect(.degrees(sx * 12))
                    .offset(x: x, y: y)
            }
        }
    }
}
struct WordmarkLetterShape: Shape {
    let d: String
    let translate: CGPoint

    // viewBox="-80 0 740 176"
    private let vbMinX: CGFloat = -80
    private let vbMinY: CGFloat = 0
    private let vbW: CGFloat = 740
    private let vbH: CGFloat = 176

    func path(in rect: CGRect) -> Path {
        let s = min(rect.width / vbW, rect.height / vbH)
        let drawW = vbW * s
        let drawH = vbH * s
        let ox = rect.minX + (rect.width - drawW) / 2
        let oy = rect.minY + (rect.height - drawH) / 2

        func map(_ x: CGFloat, _ y: CGFloat) -> CGPoint {
            CGPoint(
                x: ox + (x - vbMinX) * s,
                y: oy + (y - vbMinY) * s
            )
        }

        var p = Path()
        SVGPathBuilder(d: d, translate: translate).build(into: &p, map: map)
        return p
    }
}
struct WordmarkData {
    struct Letter {
        let d: String
        let translate: CGPoint
    }

    // W (u Ciebie w path jest transform="translate(82,11)")
    static let W = Letter(
        d: "M0 0 C1.57066004 0.14070417 3.14089306 0.28617911 4.7109375 0.43359375 C5.58540527 0.51407959 6.45987305 0.59456543 7.36083984 0.67749023 C11.02380769 1.125111 14.44708363 2.01307879 18 3 C17.95456055 4.28124756 17.95456055 4.28124756 17.90820312 5.58837891 C17.30994814 22.73298625 16.86795511 39.84250107 17 57 C19.17102305 52.27283462 21.33968558 47.54459548 23.50634766 42.81542969 C24.24075626 41.2132585 24.97576301 39.61136133 25.71142578 38.00976562 C30.27986722 28.06265439 34.75001552 18.08785286 39 8 C40.39583333 8.14583333 41.79166667 8.29166667 43.1875 8.4375 C43.96480469 8.51871094 44.74210937 8.59992187 45.54296875 8.68359375 C48.04640786 9.00597621 50.52490524 9.50498105 53 10 C53.66 28.48 54.32 46.96 55 66 C61.2089505 49.96452346 61.2089505 49.96452346 67.41577148 33.92822266 C68.19246812 31.9234726 68.96923721 29.9187506 69.74609375 27.9140625 C70.15122192 26.86629639 70.5563501 25.81853027 70.97375488 24.73901367 C71.35938599 23.74442139 71.74501709 22.7498291 72.14233398 21.72509766 C72.47764633 20.85905914 72.81295868 19.99302063 73.15843201 19.10073853 C74 17 74 17 75 15 C77.62696231 15.44879766 80.25116893 15.90854114 82.875 16.375 C83.99455078 16.56449219 83.99455078 16.56449219 85.13671875 16.7578125 C90.7734375 17.7734375 90.7734375 17.7734375 93 20 C91.97151199 22.48574248 90.94283813 24.97140781 89.9140625 27.45703125 C89.58540192 28.25131027 89.25674133 29.04558929 88.91812134 29.86393738 C87.06143198 34.34926823 85.20112374 38.83305487 83.33496094 43.31445312 C79.60893309 52.26672223 75.89855522 61.22368187 72.26998901 70.21598816 C70.66419998 74.18925604 69.04344042 78.15632381 67.42059326 82.12265015 C66.6405225 84.04008516 65.86743517 85.96037616 65.10137939 87.88345337 C64.02795411 90.5757142 62.9309265 93.25716553 61.828125 95.9375 C61.5141275 96.7428569 61.20013 97.54821381 60.87661743 98.37797546 C59.95019531 100.58984375 59.95019531 100.58984375 58 104 C53 105 53 105 40 102 C39.34 84.18 38.68 66.36 38 48 C33.0043661 58.93285886 33.0043661 58.93285886 28.00927734 69.8659668 C24.02454291 78.58585774 20.02642233 87.29925861 16 96 C14.29166667 95.875 12.58333333 95.75 10.875 95.625 C9.44800781 95.52058594 9.44800781 95.52058594 7.9921875 95.4140625 C4.80595412 94.9731477 2.03297524 94.05030127 -1 93 C-1.02356719 84.86098178 -1.04113403 76.7219787 -1.05181217 68.58293438 C-1.05694692 64.80031281 -1.06386419 61.0177152 -1.07543945 57.23510742 C-1.13239439 38.12825407 -0.89908825 19.09025278 0 0 Z ",
        translate: CGPoint(x: 82, y: 11)
    )

    // e (transform="translate(321,13)")
    static let e = Letter(
        d: "M0 0 C6.27 0 12.54 0 19 0 C19.33 10.89 19.66 21.78 20 33 C21.65 31.68 23.3 30.36 25 29 C30.31948641 27.22360216 35.68664821 27.81250167 40.859375 29.79296875 C47.12156676 33.32402213 50.74733074 39.36714051 53 46 C54.43883767 52.01048607 54.22359928 58.03943335 54.25 64.1875 C54.270625 65.36892578 54.29125 66.55035156 54.3125 67.76757812 C54.35519724 77.40114358 53.36877951 86.35746459 47 94 C41.97802755 97.79210165 38.36728433 99.15659924 32.125 99.25 C31.09632813 99.27578125 30.06765625 99.3015625 29.0078125 99.328125 C24.25701862 98.80985658 21.15057298 96.48221224 18 93 C17.67 94.65 17.34 96.3 17 98 C11.39 98 5.78 98 0 98 C0 65.66 0 33.32 0 0 Z M20 46 C18.5108291 48.97834179 18.79610606 52.04020559 18.76171875 55.30859375 C18.753647 56.03111832 18.74557526 56.75364288 18.73725891 57.49806213 C18.72342556 59.02708541 18.71270004 60.55613946 18.70483398 62.08520508 C18.68759039 64.42523372 18.64369805 66.76386024 18.59960938 69.10351562 C18.58948488 70.58853127 18.58096802 72.07355893 18.57421875 73.55859375 C18.55671066 74.2586705 18.53920258 74.95874725 18.52116394 75.68003845 C18.53573727 78.9378668 18.57004632 80.56081724 20.89941406 82.94018555 C24.48435397 84.74890523 27.00980549 84.38001852 31 84 C33.35642125 82.34279721 33.93739699 81.21994746 34.73046875 78.43359375 C36.34372654 67.85779267 36.97012565 57.43514733 34 47 C32.2778995 44.84031658 31.28391695 44.10742804 28.6875 43.125 C25.07243186 42.9568573 23.04736968 44.13002315 20 46 Z ",
        translate: CGPoint(x: 321, y: 13)
    )

    // b (transform="translate(227,58)")
    static let b1 = Letter(
        d: "M0 0 C2.71546221 0.58672853 5.37871454 1.22931067 8.0625 1.9375 C9.20041992 2.23043945 9.20041992 2.23043945 10.36132812 2.52929688 C12.24223908 3.01431165 14.12129838 3.50649664 16 4 C17.14031633 8.12780348 16.78142973 10.77262537 15.56640625 14.8515625 C15.24736328 15.94984375 14.92832031 17.048125 14.59960938 18.1796875 C14.25736328 19.31664063 13.91511719 20.45359375 13.5625 21.625 C12.8938215 23.88704385 12.22830418 26.1500253 11.56640625 28.4140625 C11.26677979 29.4138916 10.96715332 30.4137207 10.65844727 31.44384766 C9.875275 34.04426115 9.875275 34.04426115 10 37 C10.639375 36.649375 11.27875 36.29875 11.9375 35.9375 C17.10784886 34.35474015 21.53117277 34.85841429 26.44140625 37.12890625 C32.81383725 40.98175992 35.72249018 45.03289887 37.55859375 52.171875 C39.67905302 65.20067629 34.68952975 84.96313119 27.0625 95.625 C23.65692522 99.65375985 20.08277692 103.30574103 15 105 C2.39285403 105.94599075 2.39285403 105.94599075 -3 102 C-4.83261718 100.0794172 -6.39375562 98.12591168 -8 96 C-8.39574219 96.50917969 -8.79148438 97.01835937 -9.19921875 97.54296875 C-11 99 -11 99 -13.26953125 98.92578125 C-14.10871094 98.72339844 -14.94789063 98.52101563 -15.8125 98.3125 C-16.64394531 98.12300781 -17.47539062 97.93351562 -18.33203125 97.73828125 C-21.2600035 96.92805174 -24.1212138 95.96918722 -27 95 C-21.7537094 75.10166998 -16.33796466 55.25610895 -10.76098633 35.44799805 C-9.73972064 31.82018879 -8.72350541 28.19098345 -7.70835972 24.56145763 C-6.91543006 21.72911105 -6.11948994 18.89761736 -5.32264519 16.06637001 C-4.94560737 14.72498339 -4.56962484 13.38329967 -4.19473457 12.04131126 C-3.67928074 10.19747374 -3.15922395 8.35492482 -2.63891602 6.51245117 C-2.3454982 5.4682048 -2.05208038 4.42395844 -1.74977112 3.34806824 C-1 1 -1 1 0 0 Z M4 52 C2.68631676 54.97997489 2.68631676 54.97997489 1.7890625 58.4609375 C1.61241058 59.08851959 1.43575867 59.71610168 1.25375366 60.36270142 C0.88535588 61.68706212 0.52438425 63.0135083 0.17041016 64.34179688 C-0.37303038 66.36765756 -0.94833754 68.38249234 -1.52734375 70.3984375 C-1.88216484 71.68956809 -2.23509338 72.98122057 -2.5859375 74.2734375 C-2.9061084 75.44310059 -3.2262793 76.61276367 -3.55615234 77.81787109 C-4.04690813 81.33630396 -3.68421175 82.91651245 -2 86 C0.33715644 88.42062631 1.65022129 88.9489906 5 89.4375 C7.99320196 89.21362399 7.99320196 89.21362399 10.125 87.625 C16.4167046 78.81661355 19.79467543 65.83127802 19.4140625 55.0703125 C19.11101475 52.72154636 19.11101475 52.72154636 16.875 50.375 C11.78126209 47.93886448 8.10768932 48.05649512 4 52 Z ",
        translate: CGPoint(x: 227, y: 58)
    )
    
    // a (transform="translate(371,43)")
    static let a = Letter(
        d: #"M0 0 C6.6 0 13.2 0 20 0 C21.46846607 4.40539822 22.58943513 8.41765956 23.5078125 12.9296875 C23.77207031 14.21875 24.03632813 15.5078125 24.30859375 16.8359375 C24.58080952 18.18227542 24.85294394 19.5286298 25.125 20.875 C25.4046097 22.24486074 25.68455444 23.61465315 25.96484375 24.984375 C26.64652447 28.32225989 27.32479195 31.66080084 28 35 C31.31269408 23.39199409 34.30726771 11.76823742 37 0 C43.6 0 50.2 0 57 0 C55.43956454 8.67247068 53.08209284 17.05478653 50.60546875 25.5 C50.17180328 26.98629978 49.73823683 28.47262846 49.30476379 29.95898438 C48.3992389 33.05951415 47.49012003 36.15896454 46.57885742 39.2578125 C45.4197016 43.20197157 44.27330329 47.14971433 43.13006115 51.09851074 C42.24000727 54.16502917 41.34125009 57.22894785 40.44014931 60.29223633 C40.01411626 61.74558697 39.59112989 63.19983475 39.17143822 64.6550293 C32.3311268 88.33174885 32.3311268 88.33174885 23.2578125 94.109375 C20.24156266 95.29917598 17.67171127 95.26471768 14.4375 95.25 C13.30183594 95.25515625 12.16617187 95.2603125 10.99609375 95.265625 C8 95 8 95 5 93 C5.66 88.71 6.32 84.42 7 80 C9.1346875 79.7215625 9.1346875 79.7215625 11.3125 79.4375 C15.1675071 78.56329367 15.75609708 78.35150716 18.125 74.9375 C20.79542789 66.13845866 16.503652 56.20366747 13.96484375 47.8125 C13.56199908 46.46033486 13.15987602 45.10795455 12.75843811 43.75537109 C11.70803703 40.22256865 10.64873611 36.69250088 9.58721924 33.1630249 C8.29268297 28.85329537 7.00786133 24.5406619 5.72258091 20.22816467 C4.72431258 16.87881636 3.72427529 13.53003438 2.71873474 10.18286133 C2.3615889 8.99072021 2.00444305 7.7985791 1.63647461 6.5703125 C1.31972275 5.51602051 1.00297089 4.46172852 0.67662048 3.37548828 C0 1 0 1 0 0 Z"#,
        translate: CGPoint(x: 371, y: 43)
    )

    // b (drugie) (transform="translate(304.08984375,45.32421875)")
    static let b2 = Letter(
        d: #"M0 0 C5.27809789 4.25149111 7.87691307 8.97188638 8.91015625 15.67578125 C9.0807655 18.72167903 9.11847301 21.76632917 9.15625 24.81640625 C9.18919807 26.62760882 9.22240955 28.43880662 9.25585938 30.25 C9.30312993 33.08476391 9.3475691 35.91950982 9.38696289 38.75439453 C9.42700269 41.50443373 9.47847229 44.25408594 9.53125 47.00390625 C9.53966415 47.83859436 9.54807831 48.67328247 9.55674744 49.53326416 C9.58171043 50.73931305 9.58171043 50.73931305 9.60717773 51.96972656 C9.6174852 52.66302063 9.62779266 53.3563147 9.63841248 54.07061768 C10.04736241 57.9911545 11.05505807 61.82783944 11.91015625 65.67578125 C5.64015625 65.67578125 -0.62984375 65.67578125 -7.08984375 65.67578125 C-7.74984375 64.02578125 -8.40984375 62.37578125 -9.08984375 60.67578125 C-10.01796875 61.48015625 -10.94609375 62.28453125 -11.90234375 63.11328125 C-16.56831909 67.15712655 -21.17272346 67.01462258 -27.140625 66.95703125 C-32.34273769 66.46093573 -34.87862636 63.95428849 -38.33984375 60.30078125 C-42.61853437 53.88274531 -43.11040983 46.92705764 -41.66015625 39.46484375 C-39.97004034 34.01891471 -36.82965613 30.75107708 -32.08984375 27.67578125 C-25.05317268 24.59723766 -17.64463121 24.52160191 -10.08984375 24.67578125 C-10.20426836 23.07082558 -10.33179069 21.46680006 -10.46484375 19.86328125 C-10.53445313 18.96996094 -10.6040625 18.07664062 -10.67578125 17.15625 C-10.95629411 14.43179626 -10.95629411 14.43179626 -13.08984375 11.67578125 C-16.67341616 11.42562252 -16.67341616 11.42562252 -20.08984375 11.67578125 C-20.74984375 13.98578125 -21.40984375 16.29578125 -22.08984375 18.67578125 C-28.02984375 18.67578125 -33.96984375 18.67578125 -40.08984375 18.67578125 C-40.08984375 10.39844266 -39.61355991 7.39560568 -34.08984375 1.67578125 C-23.7728718 -5.25156356 -10.85068439 -6.87548039 0 0 Z M-21.890625 38.40625 C-23.21325185 40.90933208 -23.49340098 42.42539454 -23.46484375 45.23828125 C-23.47257812 46.00269531 -23.4803125 46.76710938 -23.48828125 47.5546875 C-22.99095341 50.20222687 -22.26696734 51.11567655 -20.08984375 52.67578125 C-16.75608131 52.55671831 -14.18382739 52.42429637 -11.3828125 50.5078125 C-9.49341253 47.83068686 -9.79809773 45.71990773 -9.90234375 42.48828125 C-9.92941406 41.40160156 -9.95648438 40.31492188 -9.984375 39.1953125 C-10.01917969 38.36386719 -10.05398438 37.53242187 -10.08984375 36.67578125 C-11.69252195 36.56753282 -13.29730123 36.4900748 -14.90234375 36.42578125 C-16.24232422 36.35617188 -16.24232422 36.35617188 -17.609375 36.28515625 C-20.1992594 36.45055469 -20.1992594 36.45055469 -21.890625 38.40625 Z"#,
        translate: CGPoint(x: 304.08984375, y: 45.32421875)
    )

    // y (transform="translate(198,80)")
    static let y = Letter(
        d: #"M0 0 C5.08909698 4.97024334 8.63748262 9.2272901 9.3359375 16.49609375 C9.43132804 26.1209993 8.09749777 33.81876972 5 43 C4.17274414 42.78794922 3.34548828 42.57589844 2.49316406 42.35742188 C-0.58465687 41.57089645 -3.66352595 40.78865453 -6.74316406 40.00927734 C-8.07432762 39.67146625 -9.40506342 39.33196479 -10.73535156 38.99072266 C-12.6505509 38.49975601 -14.56744681 38.01542258 -16.484375 37.53125 C-17.63647461 37.23798828 -18.78857422 36.94472656 -19.97558594 36.64257812 C-23.13679024 35.86145016 -23.13679024 35.86145016 -27 36 C-27.38932267 43.00833025 -27.38932267 43.00833025 -24 49 C-17.51415573 52.83379354 -10.16820574 52.17297912 -3 51 C-2.34 54.96 -1.68 58.92 -1 63 C-8.29319201 67.37591521 -15.18676238 68.04887162 -23.5546875 66.5390625 C-30.54315071 64.68853486 -37.3263684 61.73287467 -41.63671875 55.71484375 C-47.521237 45.3452772 -47.16337287 34.48753239 -44.3125 23.1875 C-41.11212773 12.54181724 -37.49606883 4.35599495 -28 -2 C-19.30354549 -6.49079208 -8.06244841 -5.624964 0 0 Z M-22 16 C-22.66 17.98 -23.32 19.96 -24 22 C-19.05 23.32 -14.1 24.64 -9 26 C-8.00586828 22.02347311 -7.63649642 19.0712401 -8 15 C-9.94797566 12.18625737 -11.10415102 11.20673438 -14.4375 10.4375 C-18.194255 11.26215354 -19.61751492 13.03799152 -22 16 Z"#,
        translate: CGPoint(x: 198, y: 80)
    )

}
struct WordmarkDrawView: View {
    @State private var progress: CGFloat = 0

    // ile liter pokazujesz (na start 2-3)
    private let letters: [WordmarkData.Letter] = [
        WordmarkData.W,
        WordmarkData.e,
        WordmarkData.b1,
        WordmarkData.a,
        WordmarkData.b2,
        WordmarkData.y
    ]


    var body: some View {
        let grad = LinearGradient(
            gradient: Gradient(colors: [
                Color(red: 0x6e/255, green: 0xe7/255, blue: 0xf9/255),
                Color(red: 0xa7/255, green: 0x8b/255, blue: 0xfa/255)
            ]),
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )

        ZStack {
            ForEach(letters.indices, id: \.self) { i in
                let letter = letters[i]
                let shape = WordmarkLetterShape(d: letter.d, translate: letter.translate)

                // 1) Stroke rysowany
                shape
                    .trim(from: 0, to: letterProgress(for: i))
                    .stroke(grad, style: StrokeStyle(lineWidth: 3, lineCap: .round, lineJoin: .round))

                // 2) Fill pojawia się, gdy litera “dorysowana”
                if letterProgress(for: i) >= 1 {
                    shape.fill(Color.white)
                }
            }
        }
        .onAppear {
            // prosta animacja całości od 0 do 1
            withAnimation(.linear(duration: 2.2)) {
                progress = 1
            }
        }
    }

    private func letterProgress(for index: Int) -> CGFloat {
        // dzielimy 0..1 na N liter
        let n = CGFloat(letters.count)
        let start = CGFloat(index) / n
        let end = CGFloat(index + 1) / n

        if progress <= start { return 0 }
        if progress >= end { return 1 }
        return (progress - start) / (end - start)
    }
}

private struct MyLogoShape: Shape {

    private let p1_d = "M0 0 C1.24067734 -0.00426498 2.48135468 -0.00852997 3.7596283 -0.01292419 C5.13188175 -0.01257469 6.50413517 -0.01211317 7.87638855 -0.0115509 C9.32373135 -0.01454359 10.77107335 -0.01794638 12.21841431 -0.02172852 C16.14827845 -0.03056234 20.07812082 -0.03290639 24.00799394 -0.0335443 C26.46443486 -0.03425525 28.92087025 -0.03639043 31.3773098 -0.03904152 C39.950574 -0.04829346 48.52382265 -0.05237667 57.09709167 -0.05158997 C65.0825315 -0.05098947 73.06790371 -0.0615362 81.05332643 -0.07733363 C87.91376017 -0.09042076 94.77417185 -0.09577336 101.63461798 -0.09513456 C105.72996535 -0.09487988 109.82525264 -0.09771426 113.92058754 -0.10831261 C117.77424257 -0.11801313 121.62778036 -0.1180594 125.48143959 -0.11079597 C126.8927172 -0.1097525 128.30400219 -0.11209889 129.71526718 -0.11815643 C145.6026436 -0.18191099 145.6026436 -0.18191099 152.19743347 4.38371277 C156.27662577 8.46290507 158.09109577 11.99952749 158.28800964 17.76213074 C158.28753878 19.55012428 158.27083415 21.33816566 158.24040222 23.12590027 C158.23615738 24.07184052 158.23191254 25.01778076 158.22753906 25.99238586 C158.21081654 28.9981241 158.1731761 32.00317897 158.13493347 35.00871277 C158.11987833 37.05297388 158.10619138 39.09724556 158.09391785 41.14152527 C158.06093402 46.13918231 158.00919601 51.13633188 157.94743347 56.13371277 C158.63688049 56.12140121 159.32632751 56.10908966 160.03666687 56.09640503 C161.93749602 56.06246165 163.83833474 56.02905059 165.73918152 55.99610901 C167.7286745 55.95945503 169.71800953 55.91395354 171.7071991 55.8634491 C178.76812994 55.802871 184.63210287 56.31312276 190.22477722 61.07121277 C190.77262878 61.75183777 191.32048035 62.43246277 191.88493347 63.13371277 C192.45083191 63.81433777 193.01673035 64.49496277 193.59977722 65.19621277 C196.34329853 69.14052167 196.10733989 73.08355228 196.12443542 77.69108582 C196.13100662 78.4589592 196.13757782 79.22683258 196.14434814 80.01797485 C196.16406521 82.56046144 196.17574165 85.10288892 196.18571472 87.64543152 C196.18979025 88.51530008 196.19386578 89.38516865 196.1980648 90.28139687 C196.21892114 94.88768399 196.2332234 99.49394138 196.24259949 104.1002655 C196.25364866 108.84705059 196.28803241 113.59336493 196.32777119 118.33998394 C196.35397988 121.99898114 196.3622952 125.65786704 196.36588097 129.31694984 C196.37073781 131.06596357 196.38232601 132.81497263 196.40091896 134.56389427 C196.42539631 137.01942537 196.42432993 139.47375007 196.41740417 141.92936707 C196.43021423 142.64395081 196.44302429 143.35853455 196.45622253 144.09477234 C196.40114506 149.48681325 194.879002 153.60608535 191.94743347 158.13371277 C186.92002957 163.03220888 182.26821518 164.3852152 175.34786987 164.3742218 C174.69839648 164.37593065 174.04892308 164.3776395 173.37976867 164.37940013 C171.21169894 164.38268451 169.0439413 164.37170898 166.87590027 164.36076355 C165.31853238 164.36019921 163.76116396 164.36051645 162.20379639 164.36164856 C157.98103994 164.36222217 153.75839721 164.35046643 149.53566718 164.33650064 C145.12074851 164.32399477 140.70582721 164.3228229 136.29089355 164.32044983 C127.93286666 164.31423464 119.5748921 164.29782329 111.21688825 164.27775085 C101.70063665 164.25539307 92.18438254 164.24439872 82.66811121 164.23435998 C63.09452275 164.21345711 43.52098141 164.17828036 23.94743347 164.13371277 C23.95019885 164.92516693 23.95296423 165.71662109 23.95581341 166.53205872 C24.02211197 185.80391241 24.07173291 205.0757433 24.10286999 224.34768677 C24.11832848 233.66751709 24.13939854 242.98727121 24.17375183 252.30705261 C24.20368535 260.43166786 24.22301587 268.5562279 24.22969896 276.68089676 C24.23360452 280.98150212 24.2427619 285.28194959 24.26462364 289.58250427 C24.28505128 293.63393727 24.29125464 297.68514797 24.28675652 301.73662758 C24.28757892 303.22005739 24.29350717 304.70349498 24.3050499 306.18688011 C24.37488273 315.6277908 24.05420109 322.42917894 18.75993347 330.44621277 C13.41455389 335.55401992 7.27195222 336.58530526 0.00602722 336.5377655 C-1.11761734 336.54806038 -1.11761734 336.54806038 -2.26396179 336.55856323 C-4.71452854 336.5767093 -7.16444771 336.573012 -9.61506653 336.56730652 C-11.33324896 336.57187367 -13.05142956 336.57718083 -14.76960754 336.58319092 C-18.36042226 336.59209766 -21.95101426 336.58972618 -25.54182434 336.57975769 C-30.1282401 336.56826164 -34.71388664 336.58850136 -39.30020142 336.61767483 C-42.84513678 336.63607667 -46.38988906 336.63573663 -49.93486023 336.63003731 C-51.62523987 336.62988463 -53.31563235 336.6358844 -55.00596619 336.64832878 C-73.3620646 336.76446308 -73.3620646 336.76446308 -79.89241028 330.31730652 C-80.25463684 329.74109558 -80.6168634 329.16488464 -80.99006653 328.57121277 C-81.37033997 327.99242371 -81.7506134 327.41363464 -82.14241028 326.81730652 C-84.02666907 323.3318321 -84.1707611 320.47248647 -84.15022278 316.59074402 C-84.14700012 315.51759949 -84.14377747 314.44445496 -84.14045715 313.33879089 C-84.12788879 311.65946472 -84.12788879 311.65946472 -84.11506653 309.94621277 C-84.11055481 308.81506042 -84.10604309 307.68390808 -84.10139465 306.51847839 C-84.08960151 303.7235035 -84.07314303 300.92863457 -84.05256653 298.13371277 C-85.31326965 298.15989685 -86.57397278 298.18608093 -87.87287903 298.21305847 C-92.57663535 298.30396259 -97.28031494 298.36110787 -101.98469543 298.40837097 C-104.015753 298.43342381 -106.04672123 298.46747596 -108.07746887 298.51091003 C-111.00689301 298.57196963 -113.93511931 298.60001503 -116.86506653 298.62199402 C-118.21398987 298.66070366 -118.21398987 298.66070366 -119.59016418 298.70019531 C-125.97144058 298.70299661 -130.09878777 297.18495362 -135.05256653 293.13371277 C-139.36071893 288.49416403 -140.17602852 285.20787268 -140.19973755 278.98034668 C-140.20689285 277.69200424 -140.21404816 276.4036618 -140.22142029 275.07627869 C-140.22426055 273.64530969 -140.22697228 272.21434043 -140.22956848 270.78337097 C-140.23583397 269.27868493 -140.24248084 267.77400043 -140.2494812 266.26931763 C-140.27051641 261.32438737 -140.28088405 256.37945683 -140.29084778 251.43449402 C-140.29489573 249.73118257 -140.29901267 248.02787128 -140.30319786 246.32456017 C-140.32224947 238.32085668 -140.33647976 230.31716242 -140.34480983 222.31344062 C-140.35457826 213.0805097 -140.38088753 203.84781878 -140.42131072 194.61497241 C-140.45149525 187.47514117 -140.46628098 180.33537862 -140.46959084 173.19548482 C-140.47193895 168.93289141 -140.48086788 164.6705544 -140.50605202 160.40802956 C-140.52937836 156.39506714 -140.53354784 152.38252909 -140.52329063 148.36951637 C-140.52279624 146.90059495 -140.52908815 145.43165232 -140.54284668 143.96279526 C-140.6136768 135.94943038 -140.53446302 129.92531488 -136.05256653 123.13371277 C-131.25751688 118.33866312 -125.99926508 116.90360851 -119.29206848 116.75309753 C-105.7725072 116.79009336 -105.7725072 116.79009336 -100.05256653 121.13371277 C-95.81627514 125.64695299 -93.92593813 129.93731083 -93.93231201 136.08810425 C-93.93093735 137.11034088 -93.92956268 138.13257751 -93.92814636 139.18579102 C-93.93353928 140.86677132 -93.93353928 140.86677132 -93.93904114 142.58171082 C-93.93889511 143.76233093 -93.93874908 144.94295105 -93.93859863 146.15934753 C-93.93917629 149.39668718 -93.9441947 152.63398372 -93.95117259 155.87131476 C-93.95742005 159.25458066 -93.95801103 162.63784739 -93.959198 166.02111816 C-93.9623072 172.42777493 -93.97051506 178.83441464 -93.98054749 185.24106389 C-93.99172137 192.53482546 -93.99722229 199.82858783 -94.00224292 207.12235582 C-94.012698 222.12615097 -94.03028951 237.12993017 -94.05256653 252.13371277 C-91.08256653 251.80371277 -88.11256653 251.47371277 -85.05256653 251.13371277 C-85.04670029 249.6436673 -85.04083405 248.15362183 -85.03479004 246.61842346 C-84.97759467 232.58098409 -84.90502656 218.54368938 -84.81685162 204.50641441 C-84.77191323 197.28958472 -84.73249412 190.07280416 -84.70613098 182.85588074 C-84.68313496 176.56456018 -84.64971918 170.27339536 -84.60386497 163.98219836 C-84.57995405 160.65196539 -84.56276568 157.32191913 -84.55495262 153.99160385 C-84.54533943 150.27099899 -84.51731177 146.55095684 -84.48493958 142.83049011 C-84.48637466 141.72997314 -84.48780975 140.62945618 -84.48928833 139.49559021 C-84.40972943 133.03636631 -83.87935681 128.33695212 -79.43928528 123.30558777 C-78.87854309 122.83636902 -78.3178009 122.36715027 -77.74006653 121.88371277 C-77.18705872 121.40418152 -76.6340509 120.92465027 -76.06428528 120.43058777 C-68.55373858 115.58883728 -57.99651707 116.15491852 -49.44319153 117.56340027 C-44.25946303 119.19084991 -40.91093387 122.67320323 -38.05256653 127.13371277 C-36.15472666 131.09210204 -35.80497613 134.24663973 -35.8120575 138.61938477 C-35.80930817 139.93045197 -35.80655884 141.24151917 -35.8037262 142.59231567 C-35.81080364 144.03816315 -35.81807325 145.4840097 -35.82551575 146.92985535 C-35.8260801 148.45766696 -35.82576282 149.98547911 -35.82463074 151.51329041 C-35.82405718 155.65547183 -35.83581197 159.79753729 -35.84977865 163.93969178 C-35.8622855 168.27052869 -35.86345648 172.60136828 -35.86582947 176.93222046 C-35.87204437 185.130876 -35.88845533 193.32947816 -35.90852845 201.52811021 C-35.93088713 210.86298664 -35.9418808 220.19786562 -35.95191932 229.53276217 C-35.97282154 248.73310929 -36.00799772 267.93340674 -36.05256653 287.13371277 C-32.42256653 287.13371277 -28.79256653 287.13371277 -25.05256653 287.13371277 C-25.05533191 286.34225861 -25.05809729 285.55080444 -25.06094646 284.73536682 C-25.12724503 265.46351312 -25.17686597 246.19168224 -25.20800304 226.91973877 C-25.22346154 217.59990845 -25.2445316 208.28015433 -25.27888489 198.96037292 C-25.3088184 190.83575768 -25.32814893 182.71119763 -25.33483201 174.58652878 C-25.33873758 170.28592342 -25.34789496 165.98547595 -25.3697567 161.68492126 C-25.39018433 157.63348827 -25.3963877 153.58227757 -25.39188957 149.53079796 C-25.39271197 148.04736814 -25.39864023 146.56393056 -25.41018295 145.08054543 C-25.53462242 128.25720001 -25.53462242 128.25720001 -19.67756653 121.32121277 C-14.86619219 117.31173415 -11.75384267 115.76000036 -5.41503906 115.73498535 C-4.43470364 115.72501511 -4.43470364 115.72501511 -3.43456346 115.71484345 C-1.25262783 115.69624522 0.92875789 115.69881646 3.11076355 115.70133972 C4.67799146 115.69232058 6.24521231 115.68199298 7.81242371 115.67045593 C12.06201073 115.64287755 16.31146393 115.63360029 20.56112885 115.62760186 C25.00413456 115.61822038 29.44704022 115.59201716 33.88998413 115.56759644 C42.30109002 115.52392154 50.7121765 115.49538066 59.12336129 115.47227305 C68.70013611 115.44522669 78.27681035 115.40131483 87.85351336 115.35598433 C107.55143263 115.26312388 127.249382 115.19144953 146.94743347 115.13371277 C147.27743347 111.83371277 147.60743347 108.53371277 147.94743347 105.13371277 C146.77709611 105.13786084 146.77709611 105.13786084 145.58311558 105.1420927 C126.57795787 105.20841344 107.57282333 105.25802297 88.5675745 105.28914928 C79.37668763 105.30460273 70.18587811 105.32566309 60.99504089 105.36003113 C52.98211741 105.38998015 44.96924997 105.40929884 36.95627207 105.41597825 C32.71543751 105.4198812 28.47476325 105.42902181 24.23398018 105.45090294 C20.23753525 105.47135514 16.24131575 105.47752903 12.24482346 105.47303581 C10.78277674 105.47385712 9.32072203 105.47977064 7.85872078 105.49132919 C-9.77436049 105.62382822 -9.77436049 105.62382822 -16.42756653 100.19621277 C-16.96381653 99.51558777 -17.50006653 98.83496277 -18.05256653 98.13371277 C-18.60944153 97.45308777 -19.16631653 96.77246277 -19.74006653 96.07121277 C-22.90253009 91.40281417 -22.27316032 86.23563007 -22.30256653 80.82121277 C-22.32319153 79.8834198 -22.34381653 78.94562683 -22.36506653 77.97941589 C-22.40071243 71.65672452 -21.77592059 67.2197411 -17.43928528 62.30558777 C-16.87854309 61.83636902 -16.3178009 61.36715027 -15.74006653 60.88371277 C-15.18705872 60.40418152 -14.6340509 59.92465027 -14.06428528 59.43058777 C-7.94493086 55.48568356 -1.55109619 55.86005692 5.46061707 55.90666199 C6.61241455 55.90636993 7.76421204 55.90607788 8.95091248 55.90577698 C12.74930921 55.90716776 16.5475086 55.92271746 20.34587097 55.93840027 C22.98288363 55.94213128 25.61989769 55.94497784 28.25691223 55.94697571 C34.48287333 55.95318185 40.70876385 55.96958089 46.93469393 55.98967469 C54.02537744 56.01206069 61.1160644 56.0230339 68.20677447 56.03306556 C82.78703138 56.05394793 97.36722907 56.0895118 111.94743347 56.13371277 C111.94743347 53.16371277 111.94743347 50.19371277 111.94743347 47.13371277 C110.48910599 47.1403746 109.0307785 47.14703644 107.52825928 47.15390015 C93.77149449 47.21476797 80.01474018 47.25989319 66.25787449 47.28914928 C59.18567035 47.30459053 52.11356703 47.32562725 45.04142761 47.36003113 C38.21387721 47.3932292 31.38643152 47.41057649 24.55880547 47.4183445 C21.95656119 47.42387898 19.35432251 47.43468643 16.75212288 47.45090294 C13.10168803 47.47274304 9.45168312 47.47567686 5.80119324 47.47428894 C4.19464874 47.49046768 4.19464874 47.49046768 2.5556488 47.50697327 C-4.02452689 47.47997818 -11.4221517 47.29489207 -16.63883114 42.75247478 C-21.96966537 36.61277855 -22.44139857 31.70303178 -22.49006653 23.88371277 C-22.52293762 22.96718933 -22.55580872 22.05066589 -22.5896759 21.10636902 C-22.64060938 14.61466607 -21.41697404 10.06066715 -17.05256653 5.13371277 C-11.68776794 0.99422633 -6.61259838 0.01027391 0 0 Z"
    // ^ skróciłem tutaj środek wielkiego patha "..." dla czytelności.
    // W realnym kodzie wklej CAŁE d="" dokładnie 1:1.

    private let p2_d = "M0 0 C14.5674705 11.29161972 23.73541595 27.05945281 26.109375 45.41015625 C27.29155239 62.89087763 23.94509841 80.88225721 12.45703125 94.73828125 C9.80458446 97.76859827 6.98869471 100.59558886 4.109375 103.41015625 C3.54863281 104.003125 2.98789063 104.59609375 2.41015625 105.20703125 C-9.41260451 116.7505142 -27.29032801 120.94389252 -43.23339844 120.7578125 C-62.27498843 120.14486848 -78.00784061 112.141271 -90.890625 98.41015625 C-103.24786911 84.87051167 -108.32262078 68.21015616 -108.09375 50.1484375 C-107.09118512 31.69738768 -98.48365913 15.59499971 -85.390625 2.84765625 C-61.08860677 -18.27327588 -25.71072365 -18.90584036 0 0 Z"

    // translate(...) dokładnie z Twojego SVG:
    private let p1_translate = CGPoint(x: 238.0525665283203, y: 109.86628723144531)
    private let p2_translate = CGPoint(x: 175.890625, y: 92.58984375)

    // viewBox z SVG:
    private let vbMinX: CGFloat = 0
    private let vbMinY: CGFloat = 0
    private let vbW: CGFloat = 484
    private let vbH: CGFloat = 484

    func path(in rect: CGRect) -> Path {
        let s = min(rect.width / vbW, rect.height / vbH)
        let drawW = vbW * s
        let drawH = vbH * s
        let ox = rect.minX + (rect.width - drawW) / 2
        let oy = rect.minY + (rect.height - drawH) / 2

        func map(_ x: CGFloat, _ y: CGFloat) -> CGPoint {
            CGPoint(x: ox + (x - vbMinX) * s,
                    y: oy + (y - vbMinY) * s)
        }

        var out = Path()

        var p2 = Path()
        SVGPathBuilder(d: p2_d, translate: p2_translate).build(into: &p2, map: map)
        out.addPath(p2)

        var p1 = Path()
        SVGPathBuilder(d: p1_d, translate: p1_translate).build(into: &p1, map: map)
        out.addPath(p1)

        return out
    }
}


// Minimal SVG path builder for commands M, L, C, Z (absolute coords)
private struct SVGPathBuilder {
    let d: String
    let translate: CGPoint

    func build(into path: inout Path, map: (_ x: CGFloat, _ y: CGFloat) -> CGPoint) {
        // Tokenize by spaces/commas, keep command letters
        // Tokenize by spaces/commas/newlines/tabs, keep command letters
        var tokens: [String] = []
        var current = ""

        func flushCurrent() {
            let s = current.trimmingCharacters(in: .whitespacesAndNewlines)
            if !s.isEmpty { tokens.append(s) }
            current = ""
        }

        for ch in d {
            if ch.isLetter { // M L C Z ...
                flushCurrent()
                tokens.append(String(ch))
            } else if ch == " " || ch == "," || ch == "\n" || ch == "\t" || ch == "\r" {
                flushCurrent()
            } else {
                current.append(ch)
            }
        }
        flushCurrent()


        var i = 0
        var lastPoint = CGPoint.zero
        while i < tokens.count {
            let t = tokens[i]
            if t == "M" { // MoveTo absolute
                guard i + 2 < tokens.count, let x = Double(tokens[i+1]), let y = Double(tokens[i+2]) else { break }
                let pt = map(CGFloat(x) + translate.x, CGFloat(y) + translate.y)
                path.move(to: pt)
                lastPoint = pt
                i += 3
            } else if t == "L" { // LineTo absolute
                guard i + 2 < tokens.count, let x = Double(tokens[i+1]), let y = Double(tokens[i+2]) else { break }
                let pt = map(CGFloat(x) + translate.x, CGFloat(y) + translate.y)
                path.addLine(to: pt)
                lastPoint = pt
                i += 3
            } else if t == "C" { // Cubic Bezier absolute
                guard i + 6 < tokens.count,
                      let x1 = Double(tokens[i+1]), let y1 = Double(tokens[i+2]),
                      let x2 = Double(tokens[i+3]), let y2 = Double(tokens[i+4]),
                      let x = Double(tokens[i+5]), let y = Double(tokens[i+6]) else { break }
                let c1 = map(CGFloat(x1) + translate.x, CGFloat(y1) + translate.y)
                let c2 = map(CGFloat(x2) + translate.x, CGFloat(y2) + translate.y)
                let pt = map(CGFloat(x) + translate.x, CGFloat(y) + translate.y)
                path.addCurve(to: pt, control1: c1, control2: c2)
                lastPoint = pt
                i += 7
            } else if t.uppercased() == "Z" { // Close
                path.closeSubpath()
                i += 1
            } else {
                // Some paths omit repeated command letters; handle implied C by reading in groups of 6 after a C
                // For simplicity, try to detect numeric continuation after last command
                if let lastCmd = tokens[safe: i-1], lastCmd == "C", i + 5 < tokens.count,
                   let x1 = Double(tokens[i]), let y1 = Double(tokens[i+1]),
                   let x2 = Double(tokens[i+2]), let y2 = Double(tokens[i+3]),
                   let x = Double(tokens[i+4]), let y = Double(tokens[i+5]) {
                    let c1 = map(CGFloat(x1) + translate.x, CGFloat(y1) + translate.y)
                    let c2 = map(CGFloat(x2) + translate.x, CGFloat(y2) + translate.y)
                    let pt = map(CGFloat(x) + translate.x, CGFloat(y) + translate.y)
                    path.addCurve(to: pt, control1: c1, control2: c2)
                    lastPoint = pt
                    i += 6
                } else {
                    i += 1 // skip unknown token
                }
            }
        }
    }
}

// MARK: - Bouncing logo view (replacing PulsingCircle)
private struct LogoBouncingView: View {
    @State private var bounce: CGFloat = 0
    @State private var scale: CGFloat = 1.0
    var body: some View {
        MyLogoShape()
            .fill(LinearGradient(colors: [.white], startPoint: .top, endPoint: .bottom))
            .shadow(color: .black.opacity(0.35), radius: 10, x: 0, y: 6)
            .scaleEffect(scale)
            .offset(y: bounce)
            .onAppear {
                withAnimation(.easeInOut(duration: 0.7).repeatForever(autoreverses: true)) { bounce = 8 }
                withAnimation(.easeInOut(duration: 0.9).repeatForever(autoreverses: true)) { scale = 1.06 }
            }
    }
}

struct ContentView: View {
    @State private var gameState: GameState = .splash
    @State private var score: Int = 0
    @State private var level: Int = 1
    @State private var currentTarget: GameColor = .red
    @State private var availableColors: [GameColor] = GameColor.basic
    @State private var beatTimer: Timer? = nil
    @State private var beatInterval: TimeInterval = 1.0
    @State private var timeRemaining: TimeInterval = 1.0
    @State private var lastBeatDate: Date = .init()
    @State private var backgroundPhase: CGFloat = 0
    @State private var isAnimatingBG: Bool = false
    @State private var audioPlayer: AVAudioPlayer?
    @State private var giftOpenPlayer: AVAudioPlayer? = nil
    @State private var bpm: Double = 100 // beats per minute for sync with audio
    @State private var availableTracks: [String] = [] // filenames without extension
    @State private var selectedTrack: String = "track1" // default changed to first free track
    @State private var isEstimatingBPM: Bool = false
    @AppStorage("appLanguage") private var appLanguageRaw: String = "pl"
    @State private var path = NavigationPath()

    @State private var showTrackBanner: Bool = false

    @State private var bgSpeed: Double = 8.0

    // New state properties added as requested
    @State private var freeTracks: [String] = ["track1", "track2", "track3"]
    @State private var premiumUnlocked: Bool = false
    @State private var giftAvailable: Bool = false
    @State private var correctStreak: Int = 0
    @State private var nextGiftIn: Int = 0
    @State private var allowOneFreeCustomTrack: Bool = false
    @State private var showPaywall: Bool = false

    // Additional new bonus states
    @State private var invincibleUntil: Date? = nil
    @State private var slowBgUntil: Date? = nil
    
    // Added level timer state
    @State private var levelTimeRemaining: TimeInterval = 0

    enum BonusType { case freeTrack, invincibility, slowBackground, addTime, deadly }
    @State private var pendingBonus: BonusType? = nil
    @State private var upcomingBonus: BonusType? = nil
    @State private var deadlyGiftActive: Bool = false

    // Splash related states
    @State private var showPulseVideo: Bool = true
    @State private var showFallingText: Bool = false
    @State private var musicOffset: CGFloat = -200
    @State private var coloursOffset: CGFloat = -200
    @State private var impactScale: CGFloat = 1.0

    // Added states for hit and bonus effects
    @State private var showHitEffect: Bool = false
    @State private var showBonusEffect: Bool = false

    // Added states for floating score popups
    struct ScorePopup: Identifiable { let id = UUID(); var startDate = Date() }
    @State private var scorePopups: [ScorePopup] = []

    // Added beatPulse state for beat-driven animations
    @State private var beatPulse: Bool = false

    // Added strike system state
    @State private var strikesRemaining: Int = 3

    // Added last popup text for differentiating +1/-1
    @State private var lastPopupText: String = "+1"
    
    // Added shakeTrigger for shake animation on wrong tap
    @State private var shakeTrigger: Int = 0

    private var titleKey: LocalizedStringKey { "music_colours_title" }
    private var subtitleKey: LocalizedStringKey { "subtitle" }
    private var startKey: LocalizedStringKey { "start" }
    private var scoreKey: LocalizedStringKey { "score" }
    private var levelKey: LocalizedStringKey { "level" }
    private var gameOverKey: LocalizedStringKey { "game_over" }
    private var playAgainKey: LocalizedStringKey { "play_again" }
    private var languageKey: LocalizedStringKey { "language" }

    private var effectiveBgSpeed: Double {
        if let until = slowBgUntil, until > Date() { return bgSpeed * 1.8 } // slower hue change
        return bgSpeed
    }

    var body: some View {
        NavigationStack(path: $path) {
            ZStack {
                AnimatedDepthBackground(phase: backgroundPhase, colors: availableColors.map { $0.color }, bgSpeed: effectiveBgSpeed)
                    .ignoresSafeArea()
                    .saturation(gameState == .gameOver ? 0.2 : 1.0)
                    .blur(radius: gameState == .gameOver ? 2 : 0)
                    .animation(.easeInOut(duration: 0.35), value: gameState)

                switch gameState {
                case .splash:
                    SplashView(
                        showPulseVideo: $showPulseVideo,
                        showFallingText: $showFallingText,
                        musicOffset: $musicOffset,
                        coloursOffset: $coloursOffset,
                        impactScale: $impactScale,
                        onFinish: {
                            gameState = .menu
                            isAnimatingBG = true
                        }
                    )
                    .transition(.opacity)
                case .menu:
                    MenuView(
                        appLanguage: $appLanguageRaw,
                        selectedTrack: $selectedTrack,
                        availableTracks: availableTracks,
                        bpm: bpm,
                        isEstimatingBPM: isEstimatingBPM,
                        startAction: startGame,
                        titleKey: titleKey,
                        subtitleKey: subtitleKey,
                        languageKey: languageKey,
                        startKey: startKey,
                        premiumUnlocked: $premiumUnlocked,
                        allowOneFreeCustomTrack: $allowOneFreeCustomTrack,
                        showPaywall: $showPaywall,
                        isPlaying: (audioPlayer?.isPlaying ?? false),
                        onToggleMute: {
                            if audioPlayer?.isPlaying == true {
                                stopAudio()
                            } else {
                                startAudioIfAvailable()
                            }
                        }
                    )
                case .playing:
                    GamePlayView(
                        score: score,
                        level: level,
                        target: currentTarget,
                        colors: availableColors,
                        timeRemaining: timeRemaining,
                        onTapColor: handleTap(color:),
                        scoreKey: scoreKey,
                        levelKey: levelKey,
                        giftAvailable: giftAvailable,
                        beatPulse: beatPulse,
                        levelTimeRemaining: levelTimeRemaining,
                        strikesRemaining: strikesRemaining,
                        shakeTrigger: shakeTrigger,
                        upcomingBonus: upcomingBonus
                    )
                    .transition(.scale.combined(with: .opacity))
                case .gameOver:
                    GameOverView(
                        score: score,
                        level: level,
                        restartAction: restart,
                        gameOverKey: gameOverKey,
                        playAgainKey: playAgainKey,
                        scoreKey: scoreKey,
                        levelKey: levelKey
                    )
                    .transition(.opacity)
                }

                if showTrackBanner {
                    TrackBannerView(text: selectedTrack)
                        .transition(.move(edge: .bottom).combined(with: .opacity))
                }

                if showPaywall {
                    PaywallView(onPurchase: {
                        Task { await purchasePremium() }
                    }, onClose: {
                        showPaywall = false
                    })
                    .transition(.scale.combined(with: .opacity))
                }

                if gameState == .playing { BonusIndicators(invincibleUntil: invincibleUntil, slowBgUntil: slowBgUntil) }

                OverlayLayer(showHitEffect: showHitEffect, showBonusEffect: showBonusEffect, scorePopups: scorePopups, popupText: lastPopupText)
            }
            .background(Color.black)
            .onAppear {
                setupAudioSession()
                loadAvailableTracks()
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    if audioPlayer?.isPlaying != true, !availableTracks.isEmpty {
                        print("[Audio] Auto-play on appear:", selectedTrack)
                        startAudioIfAvailable()
                    }
                }
                if gameState == .splash {
                    isAnimatingBG = false
                    showPulseVideo = true
                    showFallingText = false
                    musicOffset = -200
                    coloursOffset = -200
                    impactScale = 1.0
                }
            }
            .onChange(of: gameState) { _, newValue in
                if newValue == .playing {
                    updateBeatInterval(syncedToBPM: audioPlayer != nil)
                    resetLevelTimer()
                    startBeatLoop()
                } else {
                    stopBeatLoop()
                    if newValue == .menu {
                        if audioPlayer?.isPlaying != true, !availableTracks.isEmpty {
                            print("[Audio] Auto-play on menu entry:", selectedTrack)
                            startAudioIfAvailable()
                        }
                    }
                }
            }
            .onChange(of: selectedTrack) { _, newValue in
                print("[Audio] Track changed to:", newValue)
                stopAudio()
                startAudioIfAvailable()
            }
            .onReceive(Timer.publish(every: 1/30, on: .main, in: .common).autoconnect()) { _ in
                // Background animation handled by TimelineView
                // Countdown update while playing
                guard gameState == .playing else { return }
                let elapsed = Date().timeIntervalSince(lastBeatDate)
                timeRemaining = max(0, beatInterval - elapsed)
                levelTimeRemaining = max(0, levelTimeRemaining - (1.0/30.0))
                if timeRemaining == 0 { endGame() }
                if levelTimeRemaining == 0 { endGame() }
            }
        }
    }

    func loadAvailableTracks() {
        let exts = ["m4a", "mp3"]
        var names: Set<String> = []
        for ext in exts {
            if let urls = Bundle.main.urls(forResourcesWithExtension: ext, subdirectory: nil) {
                for u in urls { names.insert(u.deletingPathExtension().lastPathComponent) }
            }
        }
        availableTracks = Array(names).sorted()
        print("[Audio] Found tracks in bundle (any ext):", availableTracks)
        // Keep only free tracks visible if not premium and no gift
        if !premiumUnlocked && !allowOneFreeCustomTrack {
            // Ensure default free names exist; if not, fall back to any found
            let presentFree = freeTracks.filter { availableTracks.contains($0) }
            if !presentFree.isEmpty {
                availableTracks = presentFree
            }
        }
        if availableTracks.isEmpty { availableTracks = freeTracks }
        if !availableTracks.contains(selectedTrack) { selectedTrack = availableTracks.first ?? "track1" }

        // Auto-play the first available track if nothing is playing yet
        if audioPlayer?.isPlaying != true, !availableTracks.isEmpty {
            print("[Audio] Auto-playing initial track:", selectedTrack)
            startAudioIfAvailable()
        }

        print("[Audio] Visible tracks:", availableTracks)
        print("[Audio] Selected track:", selectedTrack)
    }
}

// MARK: - AnimatedDepthBackground
private struct AnimatedDepthBackground: View {
    var phase: CGFloat
    var colors: [Color]
    var bgSpeed: Double

    var body: some View {
        TimelineView(.animation) { timeline in
            let t = timeline.date.timeIntervalSinceReferenceDate
            let speed = max(4.0, bgSpeed)
            let baseHue = (sin(t / speed) * 0.5 + 0.5)
            let c1 = Color(hue: baseHue, saturation: 0.55, brightness: 0.85)
            let c2 = Color(hue: (baseHue + 0.08).truncatingRemainder(dividingBy: 1.0), saturation: 0.5, brightness: 0.75)
            let c3 = Color(hue: (baseHue + 0.16).truncatingRemainder(dividingBy: 1.0), saturation: 0.45, brightness: 0.7)
            let colors = [c1, c2, c3]
            ZStack {
                LinearGradient(colors: [c1, c2], startPoint: .topLeading, endPoint: .bottomTrailing)
                    .opacity(0.6)
                ForEach(0..<3, id: \.self) { i in
                    let ph = CGFloat(t / 10.0) + CGFloat(i) * 0.8
                    Circle()
                        .fill(colors[i % 3])
                        .frame(width: 200, height: 200)
                        .blur(radius: 50)
                        .opacity(0.18)
                        .offset(x: sin(ph) * 30, y: cos(ph * 0.9) * 24)
                        .blendMode(.plusLighter)
                }
                FloatingNotesLayer(t: t, bgSpeed: speed, colors: colors)
            }
            .ignoresSafeArea()
        }
    }
}

// MARK: - Overlay Layer (group hit, bonus, and score popups)
private struct OverlayLayer: View {
    let showHitEffect: Bool
    let showBonusEffect: Bool
    let scorePopups: [ContentView.ScorePopup]
    let popupText: String

    var body: some View {
        ZStack {
            if showHitEffect { HitEffectView() }
            if showBonusEffect { BonusWowEffectView() }
            ForEach(scorePopups) { _ in FloatingPlusOneView(text: popupText) }
        }
        .allowsHitTesting(false)
    }
}

// MARK: - Pulsing Circle
private struct PulsingCircle: View {
    @State private var scale: CGFloat = 0.8
    @State private var opacity: Double = 0.8

    var body: some View {
        ZStack {
            Circle()
                .fill(LinearGradient(colors: [.pink, .purple, .blue], startPoint: .topLeading, endPoint: .bottomTrailing))
                .scaleEffect(scale)
                .opacity(opacity)
                .shadow(color: .purple.opacity(0.4), radius: 10, x: 0, y: 6)
            Circle()
                .strokeBorder(LinearGradient(colors: [.white.opacity(0.7), .clear], startPoint: .topLeading, endPoint: .bottomTrailing), lineWidth: 3)
                .scaleEffect(scale * 1.05)
                .opacity(opacity * 0.9)
        }
        .onAppear {
            withAnimation(.easeInOut(duration: 0.9).repeatForever(autoreverses: true)) {
                scale = 1.1
                opacity = 1.0
            }
        }
    }
}

// MARK: - Splash View
private struct SplashView: View {
    @Binding var showPulseVideo: Bool
    @Binding var showFallingText: Bool
    @Binding var musicOffset: CGFloat
    @Binding var coloursOffset: CGFloat
    @Binding var impactScale: CGFloat
    var onFinish: () -> Void

    @State private var hitPlayer: AVAudioPlayer? = nil
    @State private var showWordmark: Bool = false
    @State private var wordmarkOffset: CGFloat = -160
    
    private func startWordmarkFalling() {
        // start z góry
        wordmarkOffset = -160

        // spadanie (sprężyna)
        withAnimation(.interpolatingSpring(stiffness: 180, damping: 14)) {
            wordmarkOffset = 0
        }

        // mały "impact" jak w Twoich tekstach
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.35) {
            WKInterfaceDevice.current().play(.success)
            playHit()
        }
    }


    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()
            if showPulseVideo {
                LogoBouncingView()
                    .frame(width: 120, height: 120)
                    .onAppear {
                        // Play a short intro haptic
                        WKInterfaceDevice.current().play(.start)
                        // After a short delay, transition to falling text
                        DispatchQueue.main.asyncAfter(deadline: .now() + 2.1) {
                            withAnimation(.easeInOut(duration: 0.25)) {
                                showPulseVideo = false
                                showWordmark = true
                            }
                            startWordmarkFalling()
                        }

                    }
            }
            if showWordmark {
                VStack {
                    Spacer().frame(height: 26) // żeby było wyżej niż Music/Colours (dopasujesz)
                    
                    WordmarkDrawView()
                        .frame(width: 220, height: 60)
                        .offset(y: wordmarkOffset)
                        .shadow(color: .black.opacity(0.4), radius: 8, x: 0, y: 6)

                    Spacer()
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top)
                .onAppear {
                    // Po chwili przejście do Music/Colours
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.1) {
                        withAnimation(.easeInOut(duration: 0.25)) {
                            showWordmark = false
                            showFallingText = true
                        }
                        startFalling()
                    }
                }
            }
            if showFallingText {
                VStack(spacing: 0) {
                    Text("Music")
                        .font(.system(size: 42, weight: .heavy, design: .rounded))
                        .foregroundStyle(LinearGradient(colors: [.pink, .purple, .blue], startPoint: .topLeading, endPoint: .bottomTrailing))
                        .scaleEffect(impactScale)
                        .offset(y: musicOffset)
                        .shadow(color: .black.opacity(0.4), radius: 8, x: 0, y: 6)
                    Text("Colours")
                        .font(.system(size: 42, weight: .heavy, design: .rounded))
                        .foregroundStyle(LinearGradient(colors: [.yellow, .orange, .red], startPoint: .topLeading, endPoint: .bottomTrailing))
                        .scaleEffect(impactScale)
                        .offset(y: coloursOffset)
                        .shadow(color: .black.opacity(0.4), radius: 8, x: 0, y: 6)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top)
            }
        }
    }

    private func startFalling() {
        // Animate MUSIC fall
        withAnimation(.interpolatingSpring(stiffness: 180, damping: 12)) {
            musicOffset = 0
        }
        // Impact for MUSIC
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.45) {
            WKInterfaceDevice.current().play(.success)
            playHit()
            withAnimation(.spring(response: 0.2, dampingFraction: 0.5)) { impactScale = 1.15 }
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.12) {
                withAnimation(.spring(response: 0.25, dampingFraction: 0.7)) { impactScale = 1.0 }
            }
            // Then COLOURS falls
            withAnimation(.interpolatingSpring(stiffness: 180, damping: 12)) {
                coloursOffset = 0
            }
            // Impact for COLOURS
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.45) {
                WKInterfaceDevice.current().play(.success)
                playHit()
                withAnimation(.spring(response: 0.2, dampingFraction: 0.5)) { impactScale = 1.2 }
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.14) {
                    withAnimation(.spring(response: 0.25, dampingFraction: 0.7)) { impactScale = 1.0 }
                    // Hold, then finish
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) {
                        withAnimation(.easeInOut(duration: 0.3)) {
                            showFallingText = false
                        }
                        onFinish()
                    }
                }
            }
        }
    }
    
    /// Developer note: Make sure to add "hit.wav" (or hit.m4a) to your app bundle for this sound effect.
    private func playHit() {
        if let url = Bundle.main.url(forResource: "hit", withExtension: "wav") ?? Bundle.main.url(forResource: "hit", withExtension: "m4a") {
            do {
                hitPlayer = try AVAudioPlayer(contentsOf: url)
                hitPlayer?.prepareToPlay()
                hitPlayer?.play()
            } catch { }
        }
    }
}

// MARK: - Views

private struct MenuView: View {
    @Binding var appLanguage: String
    @Binding var selectedTrack: String
    let availableTracks: [String]
    let bpm: Double
    let isEstimatingBPM: Bool
    var startAction: () -> Void
    let titleKey: LocalizedStringKey
    let subtitleKey: LocalizedStringKey
    let languageKey: LocalizedStringKey
    let startKey: LocalizedStringKey
    
    // Bindings for premium and gift consumption
    @Binding var premiumUnlocked: Bool
    @Binding var allowOneFreeCustomTrack: Bool
    @Binding var showPaywall: Bool
    
    // New properties for audio playback state and control
    let isPlaying: Bool
    var onToggleMute: () -> Void

    var body: some View {
        ZStack {
            GeometryReader { proxy in
                let size = proxy.size
                Image("Ekran_startowy")
                    .resizable()
                    .scaledToFill()
                    .frame(width: size.width, height: size.height)
                    .clipped()
                    .ignoresSafeArea()
            }
            .ignoresSafeArea()
            VStack(spacing: 8) {
                Spacer(minLength: 8)
                
                Button(action: startAction) {
                    Image(systemName: "play.fill")
                        .font(.system(size: 24, weight: .bold))
                        .foregroundStyle(.black)
                        .frame(width: 60, height: 60)
                        .background(.white)
                        .clipShape(Circle())
                        .shadow(color: .black.opacity(0.25), radius: 6, x: 0, y: 4)
                }
                .buttonStyle(.plain)
                
                // Track selector
                if !availableTracks.isEmpty {
                    VStack(spacing: 4) {
                        Text("Track")
                            .font(.caption2)
                            .foregroundStyle(.white.opacity(0.8))
                        HStack(spacing: 6) {
                            Button(action: {
                                if let idx = availableTracks.firstIndex(of: selectedTrack) {
                                    let prev = (idx - 1 + availableTracks.count) % availableTracks.count
                                    selectedTrack = availableTracks[prev]
                                } else {
                                    selectedTrack = availableTracks.first ?? selectedTrack
                                }
                            }) {
                                Image(systemName: "chevron.left").font(.caption2)
                            }
                            .buttonStyle(.bordered)
                            .tint(.white)

                            MarqueeText(text: selectedTrack)
                                .frame(width: 90, height: 22)
                                .background(Capsule().fill(.ultraThinMaterial))

                            Button(action: {
                                if let idx = availableTracks.firstIndex(of: selectedTrack) {
                                    let next = (idx + 1) % availableTracks.count
                                    selectedTrack = availableTracks[next]
                                } else {
                                    selectedTrack = availableTracks.first ?? selectedTrack
                                }
                            }) {
                                Image(systemName: "chevron.right").font(.caption2)
                            }
                            .buttonStyle(.bordered)
                            .tint(.white)
                        }
                    }
                }
                
                // Compact controls panel: updated with shared translucent background
                HStack(spacing: 10) {
                    // Left: smaller mute
                    Button(action: onToggleMute) {
                        Image(systemName: isPlaying ? "speaker.wave.2.fill" : "speaker.slash.fill")
                            .font(.system(size: 14, weight: .semibold))
                            .frame(width: 26, height: 26)
                    }
                    .buttonStyle(.bordered)
                    .tint(.white)
                    .foregroundStyle(.white)

                    // Center: plus (premium/import)
                    Button(action: {
                        if premiumUnlocked || allowOneFreeCustomTrack {
                            // TODO: present file picker/import flow
                            if allowOneFreeCustomTrack {
                                allowOneFreeCustomTrack = false // consume the gift only when actually importing
                            }
                        } else {
                            showPaywall = true
                        }
                    }) {
                        Image(systemName: "plus.circle")
                            .font(.system(size: 18, weight: .semibold))
                            .frame(width: 34, height: 34)
                    }
                    .buttonStyle(.bordered)
                    .tint(.white)
                    .foregroundStyle(.white)

                    // Right: power off (same size as mute)
                    Button(action: {
                        #if os(watchOS)
                        WKExtension.shared().rootInterfaceController?.dismiss()
                        WKExtension.shared().scheduleSnapshotRefresh(withPreferredDate: Date(), userInfo: nil) { _ in }
                        #endif
                    }) {
                        Image(systemName: "power")
                            .font(.system(size: 14, weight: .semibold))
                            .frame(width: 26, height: 26)
                    }
                    .buttonStyle(.bordered)
                    .tint(.white)
                    .foregroundStyle(.white)
                }
                .padding(6)
                .background(.ultraThinMaterial, in: Capsule())
                .shadow(color: .black.opacity(0.2), radius: 4, x: 0, y: 2)
                
                Spacer(minLength: 8)
            }
            .padding()
        }
        .ignoresSafeArea()
        .background(Color.black.opacity(0.001))
    }
}

private struct GamePlayView: View {
    let score: Int
    let level: Int
    let target: GameColor
    let colors: [GameColor]
    let timeRemaining: TimeInterval
    let onTapColor: (GameColor) -> Void
    let scoreKey: LocalizedStringKey
    let levelKey: LocalizedStringKey
    let giftAvailable: Bool
    let beatPulse: Bool
    let levelTimeRemaining: TimeInterval
    let strikesRemaining: Int
    let shakeTrigger: Int
    let upcomingBonus: ContentView.BonusType?

    private func nameKey(for color: GameColor) -> LocalizedStringKey {
        switch color {
        case .red: return "color_red"
        case .green: return "color_green"
        case .blue: return "color_blue"
        case .yellow: return "color_yellow"
        case .purple: return "color_purple"
        case .orange: return "color_orange"
        }
    }
    
    private func color(for bonus: ContentView.BonusType) -> Color {
        switch bonus {
        case .freeTrack: return .pink
        case .invincibility: return .green
        case .slowBackground: return .blue
        case .addTime: return .yellow
        case .deadly: return .black
        }
    }

    var body: some View {
        VStack(spacing: 6) {
            HStack {
                HStack(spacing: 4) {
                    Text(scoreKey).font(.caption2)
                    Text("\(score)").font(.caption2)
                }
                Spacer()
                HStack(spacing: 4) {
                    Text(levelKey).font(.caption2)
                    Text("\(level)").font(.caption2)
                }
                HStack(spacing: 4) {
                    Image(systemName: "timer")
                    Text("\(Int(max(0, levelTimeRemaining)))s")
                }
                .font(.caption2)
                HStack(spacing: 2) {
                    Image(systemName: "xmark.circle")
                    Text("\(strikesRemaining)")
                }.font(.caption2)
            }
            .padding(.horizontal, 6)

            // Target indicator with ring countdown
            ZStack {
                Circle()
                    .stroke(.white.opacity(0.35), lineWidth: 3)
                    .frame(width: 90, height: 90)
                    .scaleEffect(beatPulse ? 1.08 : 0.92)
                    .opacity(beatPulse ? 0.55 : 0.2)
                    .animation(.easeOut(duration: 0.18), value: beatPulse)
                Circle()
                    .fill((giftAvailable ? Color.pink : target.color).gradient)
                    .frame(width: 70, height: 70)
                    .shadow(color: (giftAvailable ? Color.pink : target.color).opacity(0.5), radius: 6, x: 0, y: 2)
                Circle()
                    .trim(from: 0, to: max(0.01, CGFloat(timeRemaining)))
                    .stroke(.white.opacity(0.9), style: StrokeStyle(lineWidth: 4, lineCap: .round))
                    .rotationEffect(.degrees(-90))
                    .frame(width: 76, height: 76)
                    .opacity(0.9)
                if giftAvailable {
                    let bonusColor = upcomingBonus.map { color(for: $0) } ?? Color.pink
                    if upcomingBonus == .deadly {
                        Image(systemName: "gift.fill")
                            .symbolRenderingMode(.palette)
                            .foregroundStyle(.white, .black)
                            .background(
                                Circle()
                                    .fill(bonusColor)
                                    .frame(width: 34, height: 34)
                            )
                            .shadow(radius: 2)
                            .scaleEffect(beatPulse ? 1.08 : 0.95)
                            .animation(.easeOut(duration: 0.2), value: beatPulse)
                    } else {
                        Image(systemName: "gift.fill")
                            .foregroundStyle(.white)
                            .background(
                                Circle()
                                    .fill(bonusColor)
                                    .frame(width: 34, height: 34)
                            )
                            .shadow(radius: 2)
                            .scaleEffect(beatPulse ? 1.08 : 0.95)
                            .animation(.easeOut(duration: 0.2), value: beatPulse)
                    }
                } else {
                    Text(nameKey(for: target))
                        .font(.caption2).bold()
                        .foregroundStyle(.black.opacity(0.8))
                }
            }
            .modifier(ShakeEffect(trigger: shakeTrigger))
            .padding(.vertical, 4)

            // Color grid for taps (watch-friendly big buttons)
            Grid(horizontalSpacing: 6, verticalSpacing: 6) {
                GridRow {
                    ForEach(colors.prefix(2)) { c in
                        ColorButton(color: c, action: { onTapColor(c) })
                    }
                }
                GridRow {
                    ForEach(colors.suffix(from: min(2, colors.count))) { c in
                        ColorButton(color: c, action: { onTapColor(c) })
                    }
                }
            }
            .padding(.horizontal, 4)
        }
        .padding(.vertical, 4)
    }
}

private struct ColorButton: View {
    let color: GameColor
    var action: () -> Void
    @State private var pressed: Bool = false

    var body: some View {
        Button {
            pressed = true
            action()
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { pressed = false }
        } label: {
            RoundedRectangle(cornerRadius: 10, style: .continuous)
                .fill(color.color)
                .overlay(
                    RoundedRectangle(cornerRadius: 10).stroke(.white.opacity(0.2), lineWidth: 1)
                )
                .shadow(color: .black.opacity(0.25), radius: 3, x: 0, y: 2)
        }
        .buttonStyle(.plain)
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .aspectRatio(1, contentMode: .fit)
        .scaleEffect(pressed ? 0.95 : 1.0)
        .animation(.spring(response: 0.25, dampingFraction: 0.7), value: pressed)
    }
}

private struct GameOverView: View {
    let score: Int
    let level: Int
    var restartAction: () -> Void
    let gameOverKey: LocalizedStringKey
    let playAgainKey: LocalizedStringKey
    let scoreKey: LocalizedStringKey
    let levelKey: LocalizedStringKey

    var body: some View {
        VStack(spacing: 8) {
            Text(gameOverKey)
                .font(.title3).bold()
            HStack(spacing: 6) {
                HStack(spacing: 2) {
                    Text(scoreKey)
                    Text("\(score)")
                }
                Text("•")
                HStack(spacing: 2) {
                    Text(levelKey)
                    Text("\(level)")
                }
            }
            .font(.footnote)
            .opacity(0.8)
            Button(action: restartAction) {
                Text(playAgainKey)
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}

// MARK: - Bonus Indicators View
private struct BonusIndicators: View {
    let invincibleUntil: Date?
    let slowBgUntil: Date?
    @State private var now: Date = Date()

    var body: some View {
        VStack {
            HStack(spacing: 6) {
                if let inv = invincibleUntil, inv > now {
                    Label("", systemImage: "shield.fill")
                        .labelStyle(.iconOnly)
                        .foregroundStyle(.white)
                        .padding(6)
                        .background(Capsule().fill(.ultraThinMaterial))
                }
                if let slow = slowBgUntil, slow > now {
                    Label("", systemImage: "tortoise.fill")
                        .labelStyle(.iconOnly)
                        .foregroundStyle(.white)
                        .padding(6)
                        .background(Capsule().fill(.ultraThinMaterial))
                }
                Spacer()
            }
            .padding([.top, .leading], 6)
            Spacer()
        }
        .onReceive(Timer.publish(every: 0.5, on: .main, in: .common).autoconnect()) { date in
            now = date
        }
        .transition(.opacity)
    }
}

// MARK: - Track Banner View
private struct TrackBannerView: View {
    let text: String
    @State private var animate: Bool = false

    var body: some View {
        GeometryReader { proxy in
            let width = proxy.size.width
            VStack {
                Spacer()
                ZStack {
                    Capsule(style: .continuous)
                        .fill(.ultraThinMaterial)
                        .frame(height: 28)
                        .shadow(color: .black.opacity(0.2), radius: 4, x: 0, y: 2)
                    // Marquee text
                    ZStack {
                        Text(text)
                            .font(.caption2).bold()
                            .foregroundStyle(.white)
                            .offset(x: animate ? -width : width)
                            .animation(.linear(duration: 2.8), value: animate)
                    }
                    .clipped()
                }
                .padding(.horizontal, 8)
                .padding(.bottom, 6)
            }
            .onAppear { animate = true }
        }
        .ignoresSafeArea(edges: .bottom)
    }
}

// MARK: - MarqueeText (compact scrolling label)
private struct MarqueeText: View {
    let text: String
    @State private var animate: Bool = false
    @State private var textWidth: CGFloat = 0

    var body: some View {
        GeometryReader { geo in
            let w = geo.size.width
            ZStack {
                HStack(spacing: 30) {
                    marqueeText
                    marqueeText
                }
                .offset(x: animate ? -(textWidth + 30) : 0)
                .animation(.linear(duration: max(3.0, Double(textWidth + 30) / 60.0)).repeatForever(autoreverses: false), value: animate)
            }
            .onAppear {
                DispatchQueue.main.async {
                    animate = true
                }
            }
            .onChange(of: text) { _, _ in
                animate = false
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                    animate = true
                }
            }
        }
        .clipped()
    }

    private var marqueeText: some View {
        Text(text)
            .font(.caption2).bold()
            .foregroundStyle(.white)
            .lineLimit(1)
            .fixedSize()
            .background(
                GeometryReader { proxy in
                    Color.clear
                        .onAppear { textWidth = proxy.size.width }
                        .onChange(of: proxy.size.width) { _, new in textWidth = new }
                }
            )
    }
}

// MARK: - Paywall View
private struct PaywallView: View {
    var onPurchase: () -> Void
    var onClose: () -> Void
    var body: some View {
        ScrollView {
            VStack(spacing: 10) {
                Text("Unlock adding your own soundtracks, more levels, and future features.")
                    .font(.caption2)
                    .multilineTextAlignment(.center)
                    .opacity(0.8)
                Button("Buy Premium", action: onPurchase)
                    .buttonStyle(.borderedProminent)
                Button("Not now", action: onClose)
                    .buttonStyle(.bordered)
            }
            .padding()
        }
        .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 16, style: .continuous))
        .padding()
    }
}

// MARK: - Icon Preview View
private struct IconPreviewView: View {
    // Variant F is the Apple-Music-inspired placeholder, meant to be exported as PNG for AppIcon usage.
    var body: some View {
        ScrollView {
            VStack(spacing: 12) {
                IconVariantA()
                IconVariantB()
                IconVariantC()
                IconVariantD()
                IconVariantE()
                IconVariantF_AppleMusicInspired()
            }
            .padding()
        }
        .navigationTitle("Icon Preview")
    }
}

private struct IconCanvas<Content: View>: View {
    @ViewBuilder var content: Content
    var body: some View {
        RoundedRectangle(cornerRadius: 24, style: .continuous)
            .fill(Color.black.opacity(0.1))
            .overlay(content.clipShape(RoundedRectangle(cornerRadius: 24, style: .continuous)))
            .aspectRatio(1, contentMode: .fit)
            .frame(maxWidth: .infinity)
            .shadow(color: .black.opacity(0.2), radius: 6, x: 0, y: 4)
    }
}

private struct IconVariantA: View { // Diagonal gradient + MC
    var body: some View {
        IconCanvas {
            LinearGradient(colors: [Color(hex: 0xFF5FA0), Color(hex: 0x9B5DE5), Color(hex: 0x3FA9F5)], startPoint: .topLeading, endPoint: .bottomTrailing)
                .overlay(
                    Text("MC").font(.system(size: 220, weight: .black, design: .rounded)).foregroundStyle(.white)
                )
        }
    }
}

private struct IconVariantB: View { // Radial glow + MC
    var body: some View {
        IconCanvas {
            RadialGradient(colors: [Color(hex: 0x3FA9F5), Color(hex: 0x7B5DE5), Color(hex: 0x1F1440)], center: .center, startRadius: 10, endRadius: 600)
                .overlay(
                    Circle().fill(.white.opacity(0.25)).frame(width: 260, height: 260)
                        .blur(radius: 20)
                )
                .overlay(
                    Text("MC").font(.system(size: 210, weight: .black, design: .rounded)).foregroundStyle(.white)
                )
        }
    }
}

private struct IconVariantC: View { // Musical note emblem
    var body: some View {
        IconCanvas {
            LinearGradient(colors: [Color(hex: 0xFF8A5B), Color(hex: 0xFF5FA0), Color(hex: 0x9B5DE5)], startPoint: .topLeading, endPoint: .bottomTrailing)
                .overlay(
                    RoundedRectangle(cornerRadius: 160, style: .continuous)
                        .fill(.white.opacity(0.12))
                        .padding(80)
                )
                .overlay(
                    Image(systemName: "music.note").resizable().scaledToFit().foregroundStyle(.white).padding(200)
                )
        }
    }
}

private struct IconVariantD: View { // Split gradient circle + MC
    var body: some View {
        IconCanvas {
            LinearGradient(colors: [Color(hex: 0x1E1E2E), Color(hex: 0x171722)], startPoint: .topLeading, endPoint: .bottomTrailing)
                .overlay(
                    ZStack {
                        Circle().fill(LinearGradient(colors: [Color(hex: 0x3FA9F5), Color(hex: 0x9B5DE5)], startPoint: .topLeading, endPoint: .bottomTrailing)).frame(width: 520, height: 520)
                        Circle().trim(from: 0.5, to: 1).rotation(Angle(degrees: 180)).stroke(LinearGradient(colors: [Color(hex: 0xFF5FA0), Color(hex: 0xFF8A5B)], startPoint: .topLeading, endPoint: .bottomTrailing), lineWidth: 260).frame(width: 520, height: 520)
                        Text("MC").font(.system(size: 200, weight: .black, design: .rounded)).foregroundStyle(.white)
                    }
                )
        }
    }
}

private struct IconVariantE: View { // Minimal stripe + MC
    var body: some View {
        IconCanvas {
            LinearGradient(colors: [Color(hex: 0x2A2A3B), Color(hex: 0x1B1B28)], startPoint: .topLeading, endPoint: .bottomTrailing)
                .overlay(
                    Polygon(points: [CGPoint(x: -200, y: 820), CGPoint(x: 200, y: 200), CGPoint(x: 1224, y: 200), CGPoint(x: 824, y: 820)])
                        .fill(LinearGradient(colors: [Color(hex: 0x3FA9F5), Color(hex: 0x9B5DE5), Color(hex: 0xFF5FA0)], startPoint: .leading, endPoint: .trailing))
                        .opacity(0.9)
                )
                .overlay(
                    Text("MC").font(.system(size: 210, weight: .black, design: .rounded)).foregroundStyle(.white)
                )
        }
    }
}

// Apple-Music-inspired layered note placeholder icon variant F
private struct IconVariantF_AppleMusicInspired: View {
    var body: some View {
        IconCanvas {
            // Background red gradient
            LinearGradient(colors: [Color(hex: 0xFF375F), Color(hex: 0xD61F4C)], startPoint: .topLeading, endPoint: .bottomTrailing)
                .overlay(
                    ZStack {
                        // Layered notes to simulate relief
                        NoteLayer(color1: Color(hex: 0xC81E46), color2: Color(hex: 0xA8153A), scale: 1.25, offset: CGSize(width: 28, height: 28))
                        NoteLayer(color1: Color(hex: 0xE62A55), color2: Color(hex: 0xC81E46), scale: 1.33, offset: CGSize(width: 14, height: 14))
                        NoteLayer(color1: Color(hex: 0xFF546E), color2: Color(hex: 0xE52B54), scale: 1.42, offset: .zero)
                        // White text on top
                        Text("Music")
                            .font(.system(size: 120, weight: .black, design: .rounded))
                            .foregroundStyle(.white)
                            .shadow(color: .black.opacity(0.25), radius: 8, x: 0, y: 6)
                            .offset(y: 110)
                    }
                )
        }
    }
}

private struct NoteLayer: View {
    var color1: Color
    var color2: Color
    var scale: CGFloat
    var offset: CGSize

    var body: some View {
        musicalNote
            .fill(LinearGradient(colors: [color1, color2], startPoint: .top, endPoint: .bottom))
            .scaleEffect(scale)
            .offset(offset)
            .shadow(color: .black.opacity(0.25), radius: 12, x: 0, y: 10)
            .overlay(
                musicalNote
                    .stroke(.black.opacity(0.12), lineWidth: 1)
                    .scaleEffect(scale)
                    .offset(offset)
                    .blendMode(.multiply)
            )
    }

    private var musicalNote: Path {
        Path { p in
            // Stylized rounded note: stem + head
            // Stem
            p.move(to: CGPoint(x: 540, y: 270))
            p.addLine(to: CGPoint(x: 540, y: 520))
            // Head (rounded oval)
            p.addRoundedRect(in: CGRect(x: 440, y: 500, width: 160, height: 110), cornerSize: CGSize(width: 40, height: 40))
            // Top cap
            p.addRoundedRect(in: CGRect(x: 480, y: 250, width: 120, height: 60), cornerSize: CGSize(width: 24, height: 24))
        }
    }
}

// MARK: - Logic
private extension ContentView {
    enum GameState { case splash, menu, playing, gameOver }
    
    func resetLevelTimer() {
        // Aim for ~40 beats per level but never less than 120s
        let target = beatInterval * 40.0
        levelTimeRemaining = max(120.0, target)
    }

    func startGame() {
        score = 0
        level = 1
        availableColors = GameColor.basic
        strikesRemaining = 3
        correctStreak = 0
        // Changed here as requested:
        nextGiftIn = Int.random(in: 2...3)
        upcomingBonus = nil
        giftAvailable = false
        deadlyGiftActive = false
        estimateBPMIfNeededAndThenStart()
        nextBeat(newLevel: true)
        gameState = .playing
        beatPulse.toggle()
        showTrackBanner = true
        DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) { showTrackBanner = false }
        playTick()
    }

    func restart() {
        gameState = .menu
        stopAudio()
    }

    func startBeatLoop() {
        updateBeatInterval(syncedToBPM: true)
        resetLevelTimer()
        lastBeatDate = Date()
        timeRemaining = beatInterval
        beatTimer?.invalidate()
        beatTimer = Timer.scheduledTimer(withTimeInterval: beatInterval, repeats: true) { _ in
            nextBeat()
            playTick()
            beatPulse.toggle()
        }
    }

    func stopBeatLoop() { beatTimer?.invalidate(); beatTimer = nil }

    func nextBeat(newLevel: Bool = false) {
        currentTarget = availableColors.randomElement() ?? .red
        lastBeatDate = Date()
        timeRemaining = beatInterval
        if !newLevel { // if called by timer, missing tap ends game
            // No-op here; miss detection is handled by countdown reaching 0 in onReceive
        }
    }

    func handleTap(color: GameColor) {
        guard gameState == .playing else { return }
        // Handle gift bonus tap first
        if giftAvailable {
            if upcomingBonus == .deadly {
                // Deadly gift ends the game
                giftAvailable = false
                upcomingBonus = nil
                deadlyGiftActive = false
                showBonusEffect = true // flash
                WKInterfaceDevice.current().play(.failure)
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { showBonusEffect = false }
                endGame()
                return
            }
            let roll = Double.random(in: 0...1)
            if roll < 0.25 { pendingBonus = .freeTrack }
            else if roll < 0.5 { pendingBonus = .invincibility }
            else if roll < 0.75 { pendingBonus = .slowBackground }
            else { pendingBonus = .addTime }
            print("[Bonus] Gift collected: \(String(describing: pendingBonus))")
            applyPendingBonus()
            giftAvailable = false
            upcomingBonus = nil
            
            // Show bigger bonus effect with special gift open sound
            showBonusEffect = true
            playGiftOpen()
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { showBonusEffect = false }
            
            playSuccess()
            return
        }
        if color == currentTarget {
            correctStreak += 1
            score += 1
            lastPopupText = "+1"
            
            // Show hit effect
            showHitEffect = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.35) { showHitEffect = false }
            
            // Add floating score popup
            scorePopups.append(ScorePopup())
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
                if !scorePopups.isEmpty { _ = scorePopups.removeFirst() }
            }
            
            if correctStreak >= nextGiftIn {
                print("[Bonus] Gift spawned. nextGiftIn reached: \(nextGiftIn)")
                giftAvailable = true
                correctStreak = 0
                // Changed here as requested:
                nextGiftIn = Int.random(in: 2...3)
                print("[Bonus] Next gift in:", nextGiftIn)
                // Pre-roll a bonus type for preview color
                let roll = Double.random(in: 0...1)
                if roll < 0.15 { // ~15% chance deadly gift
                    upcomingBonus = .deadly
                    deadlyGiftActive = true
                } else if roll < 0.35 { upcomingBonus = .freeTrack }
                else if roll < 0.6 { upcomingBonus = .invincibility }
                else if roll < 0.8 { upcomingBonus = .slowBackground }
                else { upcomingBonus = .addTime }
            }
            
            advanceDifficultyIfNeeded()
            nextBeat()
            playSuccess()
        } else {
            // Wrong tap handling: penalty and strikes
            if score > 0 { score -= 1 }
            lastPopupText = "-1"
            // Show -1 popup
            scorePopups.append(ScorePopup())
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
                if !scorePopups.isEmpty { _ = scorePopups.removeFirst() }
            }
            strikesRemaining -= 1
            
            // Trigger shake animation on wrong tap
            shakeTrigger += 1
            
            if strikesRemaining <= 0 {
                endGame()
                playFail()
            } else {
                playTick()
            }
        }
    }

    func applyPendingBonus() {
        guard let bonus = pendingBonus else { return }
        switch bonus {
        case .freeTrack:
            allowOneFreeCustomTrack = true
        case .invincibility:
            invincibleUntil = Date().addingTimeInterval(5)
        case .slowBackground:
            slowBgUntil = Date().addingTimeInterval(8)
        case .addTime:
            levelTimeRemaining += max(5, beatInterval * 8) // add ~8 beats (min 5s)
        case .deadly:
            // No direct apply logic needed here, handled immediately on tap
            break
        }
        pendingBonus = nil
        upcomingBonus = nil
        deadlyGiftActive = false
    }

    func advanceDifficultyIfNeeded() {
        // Increase level every 10 points, add colors and speed up, cycle tracks
        let newLevel = score / 10 + 1
        if newLevel > level {
            level = newLevel
            // Add colors progressively
            if availableColors.count < GameColor.all.count {
                availableColors = Array(GameColor.all.prefix(min(GameColor.all.count, 2 + level)))
            }
            // Speed up
            updateBeatInterval(syncedToBPM: audioPlayer != nil)
            resetLevelTimer()
            if gameState == .playing { startBeatLoop() }
            // Change track on level up (cycle through free tracks if not premium)
            if !premiumUnlocked && !allowOneFreeCustomTrack {
                if let idx = freeTracks.firstIndex(of: selectedTrack) {
                    let next = freeTracks[(idx + 1) % freeTracks.count]
                    selectedTrack = next
                } else {
                    selectedTrack = freeTracks.first ?? selectedTrack
                }
            }
            // Restart audio with new track
            stopAudio()
            startAudioIfAvailable()
            // giftAvailable = (Double.random(in: 0...1) < 0.5) && level >= 1
            /* gift spawning handled by streak logic */
        }
    }

    func updateBeatInterval(syncedToBPM: Bool = false) {
        if syncedToBPM {
            // Sync interval to BPM from audio track
            let levelFactor = max(0.75, 1.0 - Double(level - 1) * 0.05)
            beatInterval = max(0.25, (60.0 / bpm) * levelFactor)
        } else {
            // Fallback tempo when no audio or not syncing
            let base: TimeInterval = 1.0
            let speedFactor = max(0.35, 1.0 - Double(level - 1) * 0.1)
            beatInterval = base * speedFactor
        }
        // Adjust background speed relative to beat interval
        bgSpeed = max(4.0, min(12.0, 60.0 / max(0.5, beatInterval)))
        if levelTimeRemaining == 0 { levelTimeRemaining = beatInterval * 40.0 }
    }

    func endGame() {
        gameState = .gameOver
        stopAudio()
    }
}

// MARK: - Audio (simple ticks)
private extension ContentView {
    func startAudioIfAvailable() {
        stopAudio()
        print("[Audio] startAudioIfAvailable -> selected:", selectedTrack)
        // Try to load an audio file named selectedTrack from bundle (m4a or mp3)
        let exts = ["m4a", "mp3"]
        var url: URL? = nil
        for ext in exts {
            if let u = Bundle.main.url(forResource: selectedTrack, withExtension: ext) { url = u; break }
        }
        if url == nil { print("[Audio] URL not found in main bundle for:", selectedTrack) }
        if let url {
            do {
                audioPlayer = try AVAudioPlayer(contentsOf: url)
                audioPlayer?.numberOfLoops = -1
                audioPlayer?.prepareToPlay()
                audioPlayer?.play()
                // Optionally derive BPM if known; keep manual bpm otherwise
            } catch {
                audioPlayer = nil
                print("[Audio] Failed to init AVAudioPlayer:", error.localizedDescription)
            }
        } else {
            audioPlayer = nil
        }
    }

    func stopAudio() {
        audioPlayer?.stop()
        audioPlayer = nil
    }

    func setupAudioSession() {
        do {
            try AVAudioSession.sharedInstance().setCategory(.ambient, mode: .default, options: [.mixWithOthers])
        } catch {
            print("[Audio] Failed to set audio session:", error.localizedDescription)
        }
    }

    func playTick() {
        WKInterfaceDevice.current().play(.click)
        #if canImport(AudioToolbox) && !os(watchOS)
        AudioServicesPlaySystemSound(1104)
        #endif
    }

    func playSuccess() {
        WKInterfaceDevice.current().play(.success)
        #if canImport(AudioToolbox) && !os(watchOS)
        AudioServicesPlaySystemSound(1110)
        #endif
    }

    func playFail() {
        WKInterfaceDevice.current().play(.failure)
        #if canImport(AudioToolbox) && !os(watchOS)
        AudioServicesPlaySystemSound(1107)
        #endif
    }

    func playGiftOpen() {
        if let url = Bundle.main.url(forResource: "gift_open", withExtension: "wav")
            ?? Bundle.main.url(forResource: "gift_open", withExtension: "m4a")
            ?? Bundle.main.url(forResource: "gift_open", withExtension: "mp3") {
            do {
                giftOpenPlayer = try AVAudioPlayer(contentsOf: url)
                giftOpenPlayer?.prepareToPlay()
                giftOpenPlayer?.play()
                return
            } catch {
                print("[Audio] Failed to play gift_open:", error.localizedDescription)
                // Fallback to haptic + flash sequence
            }
        }
        // Fallback: haptic sequence + background flash
        // Sequence: success -> click -> success, with quick flashes
        WKInterfaceDevice.current().play(.success)
        showBonusEffect = true
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
            WKInterfaceDevice.current().play(.click)
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            WKInterfaceDevice.current().play(.success)
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.6) {
            showBonusEffect = false
        }
    }

    func estimateBPMIfNeededAndThenStart() {
        isEstimatingBPM = true
        Task {
            print("[BPM] Estimating BPM for:", selectedTrack)
            if let url = Bundle.main.url(forResource: selectedTrack, withExtension: "m4a") ?? Bundle.main.url(forResource: selectedTrack, withExtension: "mp3") {
                if let estimated = try? estimateBPM(from: url) {
                    print("[BPM] Estimated BPM:", estimated)
                    await MainActor.run { self.bpm = estimated }
                }
            } else {
                print("[BPM] No URL found for BPM estimation in main bundle")
            }
            await MainActor.run {
                isEstimatingBPM = false
                startAudioIfAvailable()
                if gameState == .playing {
                    updateBeatInterval(syncedToBPM: true)
                    resetLevelTimer()
                    startBeatLoop()
                }
            }
        }
    }

    func estimateBPM(from url: URL) throws -> Double {
        let file = try AVAudioFile(forReading: url)
        let format = file.processingFormat
        let frameCount = UInt32(min(44100 * 20, Int(file.length))) // analyze up to ~20s
        guard let buffer = AVAudioPCMBuffer(pcmFormat: format, frameCapacity: frameCount) else { return bpm }
        try file.read(into: buffer, frameCount: frameCount)
        guard let channelData = buffer.floatChannelData?.pointee else { return bpm }
        let sampleRate = format.sampleRate
        let totalFrames = Int(buffer.frameLength)
        let hop = Int(sampleRate / 200) // 5ms hop ~200Hz
        var envelope: [Float] = []
        envelope.reserveCapacity(totalFrames / hop)
        var i = 0
        while i < totalFrames {
            let end = min(totalFrames, i + hop)
            var sum: Float = 0
            vDSP_meamgv(channelData.advanced(by: i), 1, &sum, vDSP_Length(end - i))
            envelope.append(sum)
            i += hop
        }
        // High-pass like diff to emphasize onsets
        var diff: [Float] = Array(repeating: 0, count: envelope.count)
        vDSP_vsub(Array(envelope.dropFirst()), 1, envelope, 1, &diff[1], 1, vDSP_Length(envelope.count - 1))
        // Peak picking
        let threshold = (diff.max() ?? 0) * 0.6
        var peaks: [Int] = []
        for (idx, v) in diff.enumerated() where v > threshold { peaks.append(idx) }
        if peaks.count < 2 { return bpm }
        // Convert index distances to seconds and compute median interval
        let secondsPerHop = Double(hop) / sampleRate
        var intervals: [Double] = []
        for j in 1..<peaks.count { intervals.append(Double(peaks[j] - peaks[j-1]) * secondsPerHop) }
        intervals.sort()
        let median = intervals[intervals.count/2]
        var estimated = 60.0 / median
        // Normalize to common BPM range 80-160
        while estimated < 80 { estimated *= 2 }
        while estimated > 180 { estimated /= 2 }
        return estimated
    }
    
    func purchasePremium() async {
        do {
            // Placeholder: integrate Product.products(for:) and purchase flow here.
            // For now, simulate success.
            await MainActor.run {
                premiumUnlocked = true
                showPaywall = false
                loadAvailableTracks()
            }
        }
    }
}

// MARK: - GameColor
private enum GameColor: String, CaseIterable, Identifiable, Equatable {
    case red, green, blue, yellow, purple, orange

    var id: String { rawValue }

    var color: Color {
        switch self {
        case .red: return .red
        case .green: return .green
        case .blue: return .blue
        case .yellow: return .yellow
        case .purple: return .purple
        case .orange: return .orange
        }
    }

    static var basic: [GameColor] { [.red, .green, .blue, .yellow] }
    static var all: [GameColor] { GameColor.allCases }
}

// MARK: - Safe index helper
private extension Array {
    subscript(safe index: Index) -> Element? {
        indices.contains(index) ? self[index] : nil
    }
}

private extension Color {
    init(hex: UInt32, alpha: Double = 1.0) {
        let r = Double((hex >> 16) & 0xFF) / 255.0
        let g = Double((hex >> 8) & 0xFF) / 255.0
        let b = Double(hex & 0xFF) / 255.0
        self = Color(red: r, green: g, blue: b, opacity: alpha)
    }
}

private struct Polygon: Shape {
    var points: [CGPoint]
    func path(in rect: CGRect) -> Path {
        var path = Path()
        guard let first = points.first else { return path }
        path.move(to: first)
        for p in points.dropFirst() { path.addLine(to: p) }
        path.closeSubpath()
        return path
    }
}

// MARK: - Hit Effect View
private struct HitEffectView: View {
    @State private var scale: CGFloat = 0.6
    @State private var opacity: Double = 0.9
    var body: some View {
        ZStack {
            Circle()
                .fill(LinearGradient(colors: [.white.opacity(0.7), .white.opacity(0.0)], startPoint: .center, endPoint: .bottom))
                .scaleEffect(scale)
                .opacity(opacity)
                .blendMode(.screen)
                .frame(width: 140, height: 140)
            ForEach(0..<8, id: \.self) { i in
                Capsule()
                    .fill(.white.opacity(0.8))
                    .frame(width: 2, height: 26)
                    .offset(y: -70)
                    .rotationEffect(.degrees(Double(i) * 45))
                    .opacity(opacity)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .contentShape(Rectangle())
        .allowsHitTesting(false)
        .onAppear {
            withAnimation(.easeOut(duration: 0.35)) {
                scale = 1.2
                opacity = 0.0
            }
        }
    }
}

// MARK: - Bonus Wow Effect View
private struct BonusWowEffectView: View {
    @State private var flashOpacity: Double = 0.0
    @State private var confetti: [ConfettiPiece] = (0..<32).map { _ in ConfettiPiece() }
    var body: some View {
        ZStack {
            Color.white.opacity(flashOpacity).ignoresSafeArea().blendMode(.screen)
            ForEach(confetti.indices, id: \.self) { idx in
                ConfettiPieceView(piece: confetti[idx])
            }
        }
        .allowsHitTesting(false)
        .onAppear {
            withAnimation(.easeOut(duration: 0.12)) { flashOpacity = 0.35 }
            withAnimation(.easeOut(duration: 0.5).delay(0.12)) { flashOpacity = 0.0 }
        }
    }
}

private struct ConfettiPiece: Identifiable {
    let id = UUID()
    let start: CGPoint = CGPoint(x: CGFloat.random(in: 0.2...0.8), y: 0.3)
    let end: CGPoint = CGPoint(x: CGFloat.random(in: 0.1...0.9), y: 1.2)
    let color: Color = [Color.red, .yellow, .green, .blue, .pink, .purple, .orange].randomElement()!
    let size: CGSize = CGSize(width: CGFloat.random(in: 4...8), height: CGFloat.random(in: 10...18))
    let duration: Double = Double.random(in: 0.8...1.2)
}

private struct ConfettiPieceView: View {
    let piece: ConfettiPiece
    @State private var progress: CGFloat = 0
    var body: some View {
        GeometryReader { proxy in
            let w = proxy.size.width
            let h = proxy.size.height
            let px = lerp(piece.start.x, piece.end.x, progress) * w
            let py = lerp(piece.start.y, piece.end.y, progress) * h
            Rectangle()
                .fill(piece.color)
                .frame(width: piece.size.width, height: piece.size.height)
                .position(x: px, y: py)
                .rotationEffect(.degrees(Double(progress) * 360))
                .opacity(1 - Double(progress))
                .onAppear {
                    withAnimation(.easeOut(duration: piece.duration)) { progress = 1 }
                }
        }
        .ignoresSafeArea()
    }
    private func lerp(_ a: CGFloat, _ b: CGFloat, _ t: CGFloat) -> CGFloat { a + (b - a) * t }
}

// MARK: - Floating Plus One View
private struct FloatingPlusOneView: View {
    var text: String = "+1"
    @State private var offsetY: CGFloat = 0
    @State private var opacity: Double = 1
    var body: some View {
        VStack {
            Spacer()
            Text(text)
                .font(.headline).bold()
                .foregroundStyle(.white)
                .padding(6)
                .background(Capsule().fill(Color.black.opacity(0.35)))
                .offset(y: offsetY)
                .opacity(opacity)
                .onAppear {
                    withAnimation(.easeOut(duration: 0.8)) {
                        offsetY = -60
                        opacity = 0
                    }
                }
            Spacer().frame(height: 60)
        }
        .allowsHitTesting(false)
    }
}

// MARK: - ShakeEffect for wrong taps
private struct ShakeEffect: ViewModifier {
    let trigger: Int
    @State private var offset: CGFloat = 0
    func body(content: Content) -> some View {
        content
            .offset(x: offset)
            .onChange(of: trigger) { _, _ in
                withAnimation(.default.speed(3)) {
                    offset = 12
                }
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.06) {
                    withAnimation(.default.speed(3)) { offset = -12 }
                }
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.12) {
                    withAnimation(.default.speed(3)) { offset = 0 }
                }
            }
    }
}

#Preview {
    ContentView()
}

